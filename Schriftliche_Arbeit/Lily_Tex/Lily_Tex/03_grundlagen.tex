\chapter{Grundlagen}
\label{grundlagen}
\section{Erklärende Begriffe}
Ein Programm ist die Beschreibung eines mechanischen Rechenverfahrens, sodass sie der Computer speichern und ausführen kann \parencite[vgl.][14]{rechenberg2000}. Vergleichbar ist dies mit einem Rezept. Wenn das Programm ausgeführt wird, nennt man es dann einen Prozess\parencite[vgl.][S.71]{tanenbaum2016}.Das Programm löst sozusagen einen Prozess aus. In der Analogie entspricht dies dem Koch, welcher das Rezept ausführt.  Dabei braucht ein Prozess auch “Zutaten”, um das Programm auszuführen, diese entsprechen den Betriebsmitteln. Das entspricht in der Realität zum Beispiel Arbeitsspeicher oder Dateien, Ressourcen, die beschrieben werden können. Es gibt wiederverwendbare Betriebsmittel oder konsumierbare Betriebsmittel. Die wiederverwendbaren Betriebsmittel werden von Prozessen belegt und nach deren Ausführung zur nächsten Verwendung  wieder freigegeben. Konsumierbare Betriebsmittel werden im laufenden System erzeugt (produziert) und anschließend zerstört (konsumiert).


Mit der Benutzeroberfläche des Bertriebssystems, die Schnittstelle zwischen Hard- und Software, lässt sich beobachten, dass die Programme auf den Kernen des Prozessors sehr schnell wechseln. In wenigen Milisekunden wechselt die CPU also zwischen den Programmen umher sodass zu einem Zeitpunkt nur ein Programm läuft.So können in einer Sekunde mehrere Programme laufen und es sieht es für unser Auge so aus, als würde alles gleichzeitig ausgeführt werden können. Damit  das funktioniert, wird ein Scheduler benötigt, welcher die Prozesse in eine Reihenfolge bringt und entscheidet welcher Prozess wann rechnen darf \parencite[vgl.][S.199]{tanenbaum2016}.

 Es kann allerdings auch passieren, dass ein Scheduler selbst einen verklemmten Prozess weiterrechnen lässt, was allerdings zu keinem Ergebnis führt.
Wenn nun zwei Prozesse bereit zum Rechnen sind, um das gleiche Betriebsmittel konkurrieren und das Endergebniss der zwei Prozesse davon abhängt, welcher von den Prozessen als erstes rechnen darf, wird schnell der kritische Abschnitt erreicht. Der kritische Abschnitt umfasst \glqq die Teile des Programms, in denen auf gemeinsam genutzter Speicher zugegriffen wird'' \parencite[S. 164]{tanenbaum2016}. Wenn man diesen kritischen Abschnitt betritt, kommt es zu sogenannten Race Conditions. \textit{Race Conditions} sind Situationen, \glqq in denen zwei oder mehr Prozesse einen gemeinsamen Speicher lesen oder beschreiben und das Endergebnis davon abhängt, welcher wann genau läuft'' \parencite[S. 166 f.]{tanenbaum2016}. Diese müssen vermieden werden wenn man in einer Situation ist, wo zwei Prozesse die gleiche Datei beschrieben werden sollen und es davon abhängt wann welcher Prozess rechnen darf, zum Beispiel wenn ein Dokument bedruckt werden soll. Dies funktioniert nicht wenn zwei Prozesse das Dokument beschreiben und dann kein inhaltlicher Zusammenhang mehr besteht. Verhindern kann man dies mit wechselseitigem Ausschluss. Es kommt also gar nicht dazu, dass zwei Prozesse das gleiche Betriebsmittel verwenden.

\section{Begriff Verklemmungen}
\glqq Eine Verklemmung (Deadlock)bezeichnet einen Zustand, in dem die beteiligten Prozesse wechselseitig auf den Eintritt von Bedingungen warten, die nur durch andere Prozesse aus dieser Gruppe selbst hergestellt werden können.'' \parencite[S.248]{sturm2001}. Diese wird durch Synchronisationsfehler erzeugt. 
Demnach macht keiner der Prozesse einen Fortschritt.

Es benötigt insgesamt vier Voraussetzungen damit letztendlich eine Verklemmung entsteht. Die erste ist der wechselseitige Ausschluss der Prozesse miteinander(engl. mutual exclusion). Dadurch ist ein Betriebsmittel unteilbar und exclusiv nutzbar. So werden zwar Race Conditions vermieden aber es besteht nun die Vorraussetzung, dass zwei Prozesse nicht zur selben Zeit das gleiche Betriebsmittel verwenden können. Die Zweite ist das Nachfordern von den Betriebsmitteln ohne ein anderes loszulassen (engl. hold and wait). Die konkurrierenden Prozesse können nur schrittweise die Betriebsmittel belegen. Die dritte Bedingung besteht aus dem Fakt, dass einem Prozess die Betriebsmittel nicht entzogen werden können und nicht rückforderbar sind (engl. no preemption). Damit überhaupt eine Verklemmung vorliegen kann, müssen alle diese drei Bedingungen und eine Weitere eintreten. Diese vierte Bedingung heißt auf Englisch „circular wait“ und wird mit \textit{zirkuläres Warten} übersetzt. Deshalb muss es eine geschlossene Kette an wartenden Prozessen geben. Um zu einem Ergebnis zu kommen benötigt Prozess A das, was Prozess B erst herstellen muss und Prozess B, das was Prozess A erst noch herstellen muss. Also kommt es zu einem wechselseitigen kreisförmigen(zirkulären) Warten\parencite[vgl.][S. 195f.]{baun2017}.

Neben dem Deadlock, bei dem der Prozesszustand bei \inline{BLOCKED} ist, gibt es auch noch den Livelock. Bei diesem ist der Prozesszustand bei \inline{RUNNING}, dabei führt die CPU den Prozess gar nicht aus da dieser mit einem anderen verklemmt ist. Der Livelock ist also wesentlich schwerer zu erkennen als der Deadlock \parencite[vgl.][S. 561 f.]{tanenbaum2016}.